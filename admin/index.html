<!-- 
  Cloudflare Pages Deployment
  Login Method: GitHub OAuth (via Decap CMS GitHub backend)
  
  TODO: After deploy to Cloudflare Pages:
  1. Configure a GitHub OAuth app.
  2. Set "Authorization callback URL" to "https://YOUR_CLOUDFLARE_DOMAIN/admin/"
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Content Manager</title>
    <style>
        /* Custom CSS to help with visibility states if we add classes */
        .hidden-field { display: none !important; }
    </style>
  </head>
  <body>
    <!-- Include the script that builds the page and powers Decap CMS -->
    <script src="https://unpkg.com/decap-cms@^3.1.2/dist/decap-cms.js"></script>
    
    <!-- Cloudflare Pages GitHub OAuth Setup -->
    <script>
      // ==========================================
      // 0. GITHUB OAUTH CONFIGURATION
      // ==========================================
      
      // Placeholders for Client ID and Secret.
      // NOTE: For the secure Authorization Code flow (recommended), 
      // the Client Secret should NEVER be exposed in the frontend. 
      // It should be stored in Cloudflare Pages Environment Variables and accessed via a Backend Function (/api/auth).
      
      // However, if you are using a flow that requires client-side configuration:
      const GITHUB_CLIENT_ID = window.GITHUB_CLIENT_ID || "Ov23liSOzAucLFAp8w8j";
      
      // WARNING: Putting the secret here exposes it to the public. 
      // Only do this if you understand the risks or are using a specific client-side flow.
      // ideally, this is handled by your Cloudflare Function.
      // const GITHUB_CLIENT_SECRET = "YOUR_GITHUB_CLIENT_SECRET_HERE"; 

      // If you need to manually initialize the CMS to inject these values (e.g. for Implicit flow),
      // you would set window.CMS_MANUAL_INIT = true; here and call CMS.init() yourself.
      // For now, we rely on admin/config.yml which points to /api/auth.
    </script>

    <script>
      // ==========================================
      // 1. PROFIT CALCULATION WIDGET (Read-Only)
      // ==========================================
      
      var ProfitControl = class extends React.Component {
        render() {
          return React.createElement('input', {
            type: 'text',
            value: this.props.value || '0.00',
            disabled: true,
            style: {
              width: '100%',
              backgroundColor: '#e9ecef',
              color: '#495057',
              border: '1px solid #ced4da',
              borderRadius: '5px',
              padding: '8px 12px',
              fontSize: '16px',
              fontWeight: '600',
              cursor: 'not-allowed'
            }
          });
        }
      };

      CMS.registerWidget('profit_calc', ProfitControl);

      // ==========================================
      // 2. PRE-SAVE VALIDATION
      // ==========================================

      CMS.registerEventListener({
        name: 'preSave',
        handler: ({ entry }) => {
          const data = entry.get('data');
          if (!data.has('cars')) return;
          
          const cars = data.get('cars');
          if (!cars) return;

          cars.forEach((car, index) => {
             const carName = car.get('carName') || `Car #${index + 1}`;
             const type = parseInt(car.get('arrivalOfPaymentType') || 1);

             // Helper to check field
             const check = (field, label) => {
                 if (!car.get(field)) {
                     throw new Error(`Error in "${carName}": ${label} is required.`);
                 }
             };

             // Always required (Payment 1) - Note: YAML config makes them optional to allow hiding, but we enforce here.
             check('arrivalPayment1Amount', 'Payment 1 Amount');
             check('arrivalPayment1Date', 'Payment 1 Date');

             if (type >= 2) {
                 check('arrivalPayment2Amount', 'Payment 2 Amount');
                 check('arrivalPayment2Date', 'Payment 2 Date');
             }
             if (type >= 3) {
                 check('arrivalPayment3Amount', 'Payment 3 Amount');
                 check('arrivalPayment3Date', 'Payment 3 Date');
             }
             if (type >= 4) {
                 check('arrivalPayment4Amount', 'Payment 4 Amount');
                 check('arrivalPayment4Date', 'Payment 4 Date');
             }
             if (type >= 5) {
                 check('arrivalPayment5Amount', 'Payment 5 Amount');
                 check('arrivalPayment5Date', 'Payment 5 Date');
             }
          });
        }
      });

      // ==========================================
      // 3. RUNTIME LOGIC (DOM MANIPULATION)
      // ==========================================
      // Handles: Auto-Dates, Dynamic Visibility, Profit Calculation

      document.addEventListener("DOMContentLoaded", () => {
          
          function getToday() {
              return new Date().toISOString().split('T')[0];
          }

          function setNativeValue(element, value) {
              const valueSetter = Object.getOwnPropertyDescriptor(element, 'value').set;
              const prototype = Object.getPrototypeOf(element);
              const prototypeValueSetter = Object.getOwnPropertyDescriptor(prototype, 'value').set;
              
              if (valueSetter && valueSetter !== prototypeValueSetter) {
                  prototypeValueSetter.call(element, value);
              } else {
                  valueSetter.call(element, value);
              }
              
              element.dispatchEvent(new Event('input', { bubbles: true }));
          }

          // Main loop to monitor the form
          setInterval(() => {
              // Find all car list items
              // In Decap CMS, list items usually have a specific class structure.
              // We look for the "cars" field container.
              
              // This is heuristic-based on standard Decap DOM structure.
              // Structure: .nc-widget-list > div > div (item)
              // We'll iterate inputs and group them by common ancestor.
              
              const inputs = Array.from(document.querySelectorAll('input, select'));
              if (inputs.length === 0) return;

              // Group inputs by their "car" container. 
              // We assume inputs sharing the same ID prefix (cars-X) belong to the same car.
              // IDs usually look like: "Control-input-cars-0-vin" or similar.
              
              const carGroups = {};
              
              inputs.forEach(input => {
                  const id = input.id || '';
                  const match = id.match(/cars-(\d+)-(\w+)/); // Matches cars-0-vin
                  if (match) {
                      const index = match[1];
                      const field = match[2];
                      if (!carGroups[index]) carGroups[index] = { container: input.closest('[class*="ListCard"]' || 'li') || input.parentElement.parentElement };
                      carGroups[index][field] = input;
                  }
              });

              Object.keys(carGroups).forEach(index => {
                  const group = carGroups[index];
                  
                  // --- 1. DYNAMIC VISIBILITY ---
                  const typeInput = group['arrivalOfPaymentType'];
                  if (typeInput) {
                      const type = parseInt(typeInput.value || 1);
                      
                      // Helper to hide/show field wrapper
                      const toggle = (fieldBase, show) => {
                          // We need both Amount and Date inputs
                          const amountInput = group[fieldBase + 'Amount'];
                          const dateInput = group[fieldBase + 'Date'];
                          
                          [amountInput, dateInput].forEach(inp => {
                              if (inp) {
                                  // Walk up to the field wrapper (contains label and input)
                                  // Standard structure: div > label + div > input
                                  const wrapper = inp.closest('[class*="Field"]'); // Decap class names vary, usually "Field" or div wrapper
                                  if (wrapper) {
                                      wrapper.style.display = show ? 'block' : 'none';
                                  }
                              }
                          });
                      };

                      toggle('arrivalPayment2', type >= 2);
                      toggle('arrivalPayment3', type >= 3);
                      toggle('arrivalPayment4', type >= 4);
                      toggle('arrivalPayment5', type >= 5);
                  }

                  // --- 2. AUTO-DATES ---
                  
                  // Helper for auto-date
                  const autoDate = (triggerInput, dateInput) => {
                      if (triggerInput && dateInput) {
                          const triggerVal = triggerInput.value;
                          const dateVal = dateInput.value;
                          
                          if (triggerVal && triggerVal.trim() !== '' && (!dateVal || dateVal === '')) {
                              if (!triggerInput.dataset.hasListener) {
                                  triggerInput.addEventListener('input', () => {
                                      if (triggerInput.value && !dateInput.value) {
                                          setNativeValue(dateInput, getToday());
                                      }
                                  });
                                  triggerInput.dataset.hasListener = 'true';
                              }
                          }
                      }
                  };

                  autoDate(group['vin'], group['purchaseDate']);
                  autoDate(group['shippingCost'], group['shippingCostPaymentDate']);
                  autoDate(group['arrivalPayment1Amount'], group['arrivalPayment1Date']);
                  autoDate(group['arrivalPayment2Amount'], group['arrivalPayment2Date']);
                  autoDate(group['arrivalPayment3Amount'], group['arrivalPayment3Date']);
                  autoDate(group['arrivalPayment4Amount'], group['arrivalPayment4Date']);
                  autoDate(group['arrivalPayment5Amount'], group['arrivalPayment5Date']);


                  // --- 3. PROFIT CALCULATION ---
                  const totalShippingInput = group['totalCostOfShipping'];
                  const shippingCostInput = group['shippingCost'];
                  const profitInput = group['leftOverAndProfit'];

                  if (totalShippingInput && shippingCostInput && profitInput) {
                       const calc = () => {
                           const total = parseFloat(totalShippingInput.value) || 0;
                           const ship = parseFloat(shippingCostInput.value) || 0;
                           // Ignore purchaseCost
                           const profit = (total - ship).toFixed(2);
                           
                           if (profitInput.value !== profit) {
                               setNativeValue(profitInput, profit);
                           }
                       };

                       // Attach listeners for realtime update
                       if (!totalShippingInput.dataset.profitListener) {
                           totalShippingInput.addEventListener('input', calc);
                           totalShippingInput.dataset.profitListener = 'true';
                       }
                       if (!shippingCostInput.dataset.profitListener) {
                           shippingCostInput.addEventListener('input', calc);
                           shippingCostInput.dataset.profitListener = 'true';
                       }
                       
                       // Run once
                       calc();
                  }

              });

          }, 500);
      });
    </script>
  </body>
</html>
